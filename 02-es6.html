<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ES6语法</title>
</head>
<body>

</body>
</html>
<script>
// 1、let命令（类似var）;
//    定义：用来声明变量，用法类似于var,但是所声明的变量只在let命令所在代码块内有效。
//{
//    let a = 10;
//    var b = 1;
//}
//console.log(b);
//console.log(a);//undefined,let只在它所在的的代码块有效。

//for 循环的计数器，使用let命令。
//    for (let i=0; i<10;i++){
//        console.log(i); //0-9
//    }
//    console.log(i);//undefined 注意：let只在代码块有效

//    var a = [];
//    for (var i=0; i<10; i++){
//        a[i]=function () {
//            console.log(i);
//        }
//    }
//    a[6]()

//    var a = [];
//    for (let i = 0;i<10;i++){
//        a[i] = function () {
//            console.log(i);
//        };
//    }
//    a[6]();  //结果是6

   //for 循环设置循环变量的那部分是一个父作用域，循环体内部是一个单独的子作用域。
//    for (let i = 0;i<3;i++){
//        let i = 'abc';
//        console.log(i);
//    }  //结果输出3次 abc.
    //var声明会发生变量提升问题，let不会出现
//    console.log(foo);
//    var foo = 2;
//    console.log(bar);
//    let bar = 2;

    //只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
//    var tmp = 123;
//    if (true){
//        tmp = 'abc';
//        let tmp;
//    }

//if (true) {
//    // TDZ开始
//    tmp = 'abc'; // ReferenceError
//    console.log(tmp); // ReferenceError
//
//    let tmp; // TDZ结束
//    console.log(tmp); // undefined
//
//    tmp = 123;
//    console.log(tmp); // 123
//}   //暂时性死区

    //let 不允许在相同作用域内，重复声明同一个变量。
//    function arr() {
//        let a = 10;
//        var a = 1;
//    }
//    arr();

    //块级作用域
//    var tmp = new Date();
//    function f() {
//        console.log(tmp);
//        if (false) {
//            var tmp = 'hello world';
//        }
//    }
//    f();

//    function f1() {
//        let n = 5;
//        if (true) {
//            let n = 10;
//        }
//        console.log(n); // 5
//    }
//    f1();
//let x = do {
//    let t = f();
//    t * t + 1;
//};
    // const声明一个只读的常量，一旦声明，常量的值就不能改变。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
/* ---------------------------------------------- */
    //二、变量的解构赋值。
 //  1、数组的解构赋值
   //  ① 基本用法
//    let a = 1;
//    let b = 2;
//    let c = 3;
//
//    let [a, b, c] = [1,2,3];
//    let [foo, [[bar], baz]] = [1, [[2], 3]];
//    foo // 1
//    bar // 2
//    baz // 3
//
//    let [ , , third] = ["foo", "bar", "baz"];
//    third // "baz"
//
//    let [x, , y] = [1, 2, 3];
//    x // 1
//    y // 3
//
//    let [head, ...tail] = [1, 2, 3, 4];
//    head // 1
//    tail // [2, 3, 4]
//
//    let [x, y, ...z] = ['a'];
//    x // "a"
//    y // undefined
//    z // []
    // ② 对象的解构赋值
//    let foo;
//    ({foo} = {foo: 1});
//    let baz;
//    ({bar:baz} = {bar: 1});
//
//    let obj = {
//        p: [
//            'Hello',
//            { y: 'World' }
//        ]
//    };
//
//    let { p: [x, { y }] } = obj;
//    x // "Hello"
//    y // "World"
    //③ 字符串的解构赋值
//    const [a, b, c, d, e] = 'hello';
//    let {length:len} = 'hello';
//    console.log(len);
//    let {toString: s} = 123;
//    s === Number.prototype.toString;
//    console.log(s)
//function* fibs() {
//    let a = 0;
//    let b = 1;
//    while (true) {
//        yield a;
//        [a, b] = [b, a + b];
//    }
//}
//let [first, second, third, fourth, fifth, sixth] = fibs();
//console.log(fourth)
    let code = "\u{42}";
    console.log(code)
</script>